#version 450

#include "noise.glsl"

layout(set=0, binding=0)
buffer Vertices {
	float vertices[];
};

layout(set=0, binding=1)
buffer Waves {
	int wave_len;
	vec4 waves[];
};


layout(set=1, binding=0)
uniform Uniforms {
	int time;
	vec3 cam_pos;
	mat4 cam_proj;
	vec3 light_pos;
	vec3 light_col;
	uvec2 win_size;
};

const float SCALE      = 0.7;
const float HEIGHT_LIM = 0.5;

const float M_PI = 3.1415926535897932384626433832795;

uvec3 workItems = gl_WorkGroupSize * gl_NumWorkGroups;
float noise_time = float(time) / 100;

float aspect = float(win_size.x) / win_size.y;
float sink_height = 0.5;
float modifier_size = abs(cam_pos.z + sink_height + HEIGHT_LIM);

uint to_coord(uint x, uint y) {
	return (x * workItems.x + y) * 9;
}

void vert(uint start, vec3 p, vec3 c, vec3 n) {
	vertices[start + 0] = p.x;
	vertices[start + 1] = p.y;
	vertices[start + 2] = p.z;

	vertices[start + 3] = c.x;
	vertices[start + 4] = c.y;
	vertices[start + 5] = c.z;

	vertices[start + 6] = n.x;
	vertices[start + 7] = n.y;
	vertices[start + 8] = n.z;
}

float noise_sample_method(vec2 pos) {
	return HEIGHT_LIM * noise(vec3(SCALE * pos.x, SCALE * pos.y, noise_time));
}

float sin_wave(vec2 pos, vec4 wave) {
	return HEIGHT_LIM * pow(cos(dot(wave.xy, SCALE * pos) - wave.z * noise_time), wave.w + 1);
}

float sum_of_sines_method(vec2 pos) {

	float ret = 0.0;

	for(int i = 0; i < wave_len; i++) {
		ret += sin_wave(pos, waves[i]) / wave_len;
	}

	return ret;

}

float getHeight(vec2 pos) {
	return noise_sample_method(pos);
}

vec3 norm(vec3 pos) {
	vec2 unit = vec2(1.0) / workItems.xy;

	vec2 coords1 = vec2(pos.x + unit.x, pos.y);
	vec2 coords2 = vec2(pos.x, pos.y + unit.y);

	vec3 point1 = vec3(coords1, getHeight(coords1));
	vec3 point2 = vec3(coords2, getHeight(coords2));

	vec3 tangent   = point1 - pos;
	vec3 bitangent = point2 - pos;

	vec3 raw_norm = cross(tangent, bitangent);

	return raw_norm;

}

void begin_transform(inout vec3 pos) {
	pos -= vec3(modifier_size * aspect / 2, modifier_size / 2, 0.0);
}

void final_transform(inout vec3 pos) {
	pos -= vec3(0,0, sink_height);
}

void main() {
	vec3 pos = cam_pos + vec3(modifier_size * vec2(aspect, 1.0) * gl_GlobalInvocationID.xy, 0.0) / vec3(workItems);
	begin_transform(pos);
	pos.z = getHeight(pos.xy);
	vec3 normal = norm(pos);
	final_transform(pos);

	vec3 col = vec3(0.1, 0.45, 0.50);

	vert(
		to_coord(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y),
		pos,
		col,
		normal
	);
}